struct S
{
	int a;
	char b;
	double c;
};
void init(struct S* tmp)
{
	tmp->a = 100;
	tmp->b = 'w';
	tmp->c = 3.14;
}
void print1(struct S s)//函数传参，参数需要压栈，会有时间和空间的系统开销，如果传的结构体过大时，会导致性能下降
{
	printf("%d", s.a);
	printf("%c", s.b);
	printf("%lf", s.c);
}
void print2(const struct S* s)//s是可以改变但是我只要打印就行这样会变得不太安全所以加一个const就解决
{
	printf("%d", s->a);
	printf("%c", s->b);
	printf("%lf", s->c);
}
int main()
{
	struct S s = { 0 };
	init(&s);
	print1(s);
	print2(&s);//结构体传参尽量传地址
	return 0;
}

struct s//位段单位比特位
{
	//不使用位段需要16个字节
	int a : 2;//int有32位比特位 2+5+10+30=47超出32位 所以2+5+10=17再重新开辟一个32位比特位空间使用了30
	int b : 5;//使用位段只用了4+4=8字节
	int c : 10;
	int d : 30;//注:一个位段比特位不能超过32位
};
struct s//位段单位比特位
{
	//不使用char位段需要4个字节
	char a : 3;//char有8位比特位 3+4+5+4=16超出8位 所以3+4=7再重新开辟一个8位比特位空间使用了5，还得再开辟一个使用4
	char b : 4;//使用位段只用了1+1+1=3字节
	char c : 5;
	char d : 4;//注:一个位段比特位不能超过8位
};
int main()
{
	struct s q = { 0 };
	q.a = 10;//1010因为位段只能使用3个比特位010
	q.b = 20;//10100因为位段只能使用4个比特位0100
	q.c = 3;//11因为位段只能使用5个比特位00011
	q.d = 4;//100因为位段只能使用4个比特位0100
	//初始化:0 0 0 0 0 0 0 0
	//0 0 0 0 0 0 1 0
	//0 0 1 0 0 0 1 0
	//0 0 1 0 0 0 1 0   0 0 0 0 0 0 1 1
	//0 0 1 0 0 0 1 0   0 0 0 0 0 0 1 1   0 0 0 0 0 1 0 0
	//0010 0010 0000 0011 0000 0100//在内存中16进制数2 2 0 3 0 4
	return 0;
}
